<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>proseco.acq &#8212; proseco 5.13.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-astropy.css?v=f4f7060c" />
    
    <script src="../../_static/documentation_options.js?v=0c4239ea"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">Ska!</span><span id="logotext2">proseco</span><span id="logotext3"></span></a>
  <ul>
    
    <li><a class="home" title="Homepage" href="https://cxc.cfa.harvard.edu/mta/ASPECT/tool_doc">
        <span id="logotext1">ska</span><span id="logotext2">tools</span>
    </a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../index.html">proseco 5.13.2 documentation</a>
	 &#187;
      </li>
      <li><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for proseco.acq</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Get a catalog of acquisition stars using the algorithm described in</span>
<span class="sd">https://docs.google.com/presentation/d/1VtFKAW9he2vWIQAnb6unpK4u1bVAVziIdX9TnqRS3a8</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">chandra_aca.star_probs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">acq_success_prob</span><span class="p">,</span>
    <span class="n">get_default_acq_prob_model_info</span><span class="p">,</span>
    <span class="n">prob_n_acq</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">chandra_aca.transform</span> <span class="kn">import</span> <span class="n">mag_to_count_rate</span><span class="p">,</span> <span class="n">pixels_to_yagzag</span><span class="p">,</span> <span class="n">snr_mag_for_t_ccd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">ska_helpers.utils</span> <span class="kn">import</span> <span class="n">LazyDict</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">characteristics</span> <span class="k">as</span> <span class="n">ACA</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">characteristics_acq</span> <span class="k">as</span> <span class="n">ACQ</span>
<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ACABox</span><span class="p">,</span>
    <span class="n">ACACatalogTable</span><span class="p">,</span>
    <span class="n">AliasAttribute</span><span class="p">,</span>
    <span class="n">MetaAttribute</span><span class="p">,</span>
    <span class="n">StarsTable</span><span class="p">,</span>
    <span class="n">bin2x2</span><span class="p">,</span>
    <span class="n">calc_spoiler_impact</span><span class="p">,</span>
    <span class="n">get_image_props</span><span class="p">,</span>
    <span class="n">get_mag_std</span><span class="p">,</span>
    <span class="n">pea_reject_image</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># See https://github.com/sot/skanb/blob/master/aca-acq/acq-fails-bright-stars.ipynb</span>
<span class="n">OVERLAP_P_ACQ_PENALTY</span> <span class="o">=</span> <span class="mf">0.7</span>  <span class="c1"># p_acq multiplier for search box overlap</span>
<span class="n">OVERLAP_MAG_DEADBAND</span> <span class="o">=</span> <span class="mf">0.2</span>  <span class="c1"># overlap penalty applies for mag difference &gt; deadband</span>
<span class="n">OVERLAP_PAD</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># arcsec, extra padding for overlap check</span>


<div class="viewcode-block" id="load_maxmags">
<a class="viewcode-back" href="../../api.html#proseco.acq.load_maxmags">[docs]</a>
<span class="k">def</span> <span class="nf">load_maxmags</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load maxmags from disk.</span>

<span class="sd">    Maxmag data made with analysis/interpolate-maxmags-contour-plot.ipynb</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s2">&quot;maxmags.npz&quot;</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">arrs</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arrs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">box_sz</span> <span class="ow">in</span> <span class="n">out</span><span class="p">[</span><span class="s2">&quot;box_sizes&quot;</span><span class="p">]:</span>
        <span class="n">out</span><span class="p">[</span><span class="n">box_sz</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;vals_</span><span class="si">{</span><span class="n">box_sz</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>



<span class="n">MAXMAGS</span> <span class="o">=</span> <span class="n">LazyDict</span><span class="p">(</span><span class="n">load_maxmags</span><span class="p">)</span>


<div class="viewcode-block" id="get_maxmag">
<a class="viewcode-back" href="../../api.html#proseco.acq.get_maxmag">[docs]</a>
<span class="k">def</span> <span class="nf">get_maxmag</span><span class="p">(</span><span class="n">box_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">t_ccd</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get maxmag for given box_size and t_ccd.</span>

<span class="sd">    This corresponds to the MAXMAG that results in exactly 50 search hits. See</span>
<span class="sd">    https://occweb.cfa.harvard.edu/twiki/bin/view/Aspect/PeaMaxMagTesting.</span>

<span class="sd">    Maxmag data made with analysis/interpolate-maxmags-contour-plot.ipynb.</span>

<span class="sd">    :param box_size: box size (int, arcsec)</span>
<span class="sd">    :param t_ccd: CCD temperature (float, C)</span>
<span class="sd">    :returns: maxmag (float)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">t_ccd</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">11.2</span>
    <span class="k">if</span> <span class="n">t_ccd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Clipping </span><span class="si">{</span><span class="n">t_ccd</span><span class="si">=}</span><span class="s2"> to 0.0 for interpolating MAXMAGs table&quot;</span><span class="p">)</span>
        <span class="n">t_ccd</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">maxmag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t_ccd</span><span class="p">,</span> <span class="n">xp</span><span class="o">=</span><span class="n">MAXMAGS</span><span class="p">[</span><span class="s2">&quot;t_ccds&quot;</span><span class="p">],</span> <span class="n">fp</span><span class="o">=</span><span class="n">MAXMAGS</span><span class="p">[</span><span class="n">box_size</span><span class="p">])</span>

    <span class="c1"># Need to round to nearest 0.01 mag because of values that are just slightly</span>
    <span class="c1"># below 11.2. These need to become exactly 11.2.</span>
    <span class="k">return</span> <span class="n">maxmag</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="filter_box_sizes_for_maxmag">
<a class="viewcode-back" href="../../api.html#proseco.acq.filter_box_sizes_for_maxmag">[docs]</a>
<span class="k">def</span> <span class="nf">filter_box_sizes_for_maxmag</span><span class="p">(</span>
    <span class="n">mag</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mag_err</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">box_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_ccd</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Filter the list of box sizes</span>

<span class="sd">    First compute the smallest allowed value of MAXMAG for this star, which is</span>
<span class="sd">    the star mag + 3 times the star mag error (clipped to be within 0.5 to 1.5</span>
<span class="sd">    mag, nominal).</span>

<span class="sd">    For each box size and t_ccd compute the MAXMAG that keeps the search hits</span>
<span class="sd">    at exactly 50. Then keep the box sizes where MAXMAG is less than the star</span>
<span class="sd">    minimum MAXMAG.</span>

<span class="sd">    :param mag: star mag (float)</span>
<span class="sd">    :param mag_err: star mag error (float)</span>
<span class="sd">    :param box_sizes: ndarray of box sizes (float, arcsec)</span>
<span class="sd">    :param t_ccd: CCD temperature (float, C)</span>
<span class="sd">    :returns: ndarray of box sizes (float, arcsec)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maxmag_min</span> <span class="o">=</span> <span class="n">mag</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">mag_err</span><span class="p">,</span> <span class="n">ACA</span><span class="o">.</span><span class="n">min_delta_maxmag</span><span class="p">,</span> <span class="n">ACA</span><span class="o">.</span><span class="n">max_delta_maxmag</span><span class="p">)</span>

    <span class="c1"># Hard limit of ACA.max_maxmag (11.2) from operational change made in 2019.</span>
    <span class="c1"># We always accept a maxmag of 11.2 regardless of star mag / mag_err.</span>
    <span class="n">maxmag_min</span> <span class="o">=</span> <span class="n">maxmag_min</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ACA</span><span class="o">.</span><span class="n">max_maxmag</span><span class="p">)</span>

    <span class="n">ok</span> <span class="o">=</span> <span class="p">[</span><span class="n">maxmag_min</span> <span class="o">&lt;=</span> <span class="n">get_maxmag</span><span class="p">(</span><span class="n">box_size</span><span class="p">,</span> <span class="n">t_ccd</span><span class="p">)</span> <span class="k">for</span> <span class="n">box_size</span> <span class="ow">in</span> <span class="n">box_sizes</span><span class="p">]</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">box_sizes</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>

    <span class="c1"># Always allow at least the smallest box size. This situation will be</span>
    <span class="c1"># flagged in ACA review.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">60</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="box_overlap">
<a class="viewcode-back" href="../../api.html#proseco.acq.box_overlap">[docs]</a>
<span class="k">def</span> <span class="nf">box_overlap</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">halfw1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">halfw2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if boxes overlap, False otherwise.</span>

<span class="sd">    :param y1: y centroid of first box (float, arcsec)</span>
<span class="sd">    :param z1: z centroid of first box (float, arcsec)</span>
<span class="sd">    :param halfw1: half width of first box (float, arcsec)</span>
<span class="sd">    :param y2: y centroid of second box (float, arcsec)</span>
<span class="sd">    :param z2: z centroid of second box (float, arcsec)</span>
<span class="sd">    :param halfw2: half width of second box (float, arcsec)</span>

<span class="sd">    :returns: True if boxes overlap, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">overlap_threshold</span> <span class="o">=</span> <span class="n">halfw1</span> <span class="o">+</span> <span class="n">halfw2</span> <span class="o">+</span> <span class="n">OVERLAP_PAD</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">overlap_threshold</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">z2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">overlap_threshold</span></div>



<div class="viewcode-block" id="boxes_overlap">
<a class="viewcode-back" href="../../api.html#proseco.acq.boxes_overlap">[docs]</a>
<span class="k">def</span> <span class="nf">boxes_overlap</span><span class="p">(</span>
    <span class="n">y1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">z1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">halfw1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">cand_acqs</span><span class="p">:</span> <span class="s2">&quot;AcqTable&quot;</span><span class="p">,</span>
    <span class="n">box_sizes</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">acq_indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if candidate new acq box overlaps with already selected acq boxes.</span>

<span class="sd">    This checks for overlaps between the box defined by (y1, z1, halfw1) and the boxes</span>
<span class="sd">    defined by the rows in ``cand_acqs`` (yang and zang) and ``box_sizes`` with indices</span>
<span class="sd">    in ``acq_indices``.</span>

<span class="sd">    :param y1: y centroid of first box (float, arcsec)</span>
<span class="sd">    :param z1: z centroid of first box (float, arcsec)</span>
<span class="sd">    :param halfw1: half width of first box (float, arcsec)</span>
<span class="sd">    :param cand_acqs: AcqTable of candidate acquisition stars</span>
<span class="sd">    :param box_sizes: list of box sizes of selected stars</span>
<span class="sd">    :param acq_indices: list of indices into cand_acqs of selected stars</span>

<span class="sd">    :returns: AGASC ID of the first overlapping box, or 0 if no overlap</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PROSECO_DISABLE_OVERLAP_PENALTY&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">box_size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">acq_indices</span><span class="p">,</span> <span class="n">box_sizes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">box_overlap</span><span class="p">(</span>
            <span class="n">y1</span><span class="p">,</span>
            <span class="n">z1</span><span class="p">,</span>
            <span class="n">halfw1</span><span class="p">,</span>
            <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;yang&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
            <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;zang&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
            <span class="n">box_size</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">out</span>

    <span class="k">return</span> <span class="mi">0</span></div>



<div class="viewcode-block" id="get_acq_catalog">
<a class="viewcode-back" href="../../api.html#proseco.acq.get_acq_catalog">[docs]</a>
<span class="k">def</span> <span class="nf">get_acq_catalog</span><span class="p">(</span><span class="n">obsid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a catalog of acquisition stars using the algorithm described in</span>
<span class="sd">    https://docs.google.com/presentation/d/1VtFKAW9he2vWIQAnb6unpK4u1bVAVziIdX9TnqRS3a8</span>

<span class="sd">    If ``obsid`` corresponds to an already-scheduled obsid then the parameters</span>
<span class="sd">    ``att``, ``man_angle``, ``t_ccd``, ``date``, and ``dither`` will</span>
<span class="sd">    be fetched via ``mica.starcheck`` if not explicitly provided here.</span>

<span class="sd">    :param obsid: obsid (default=0)</span>
<span class="sd">    :param att: attitude (any object that can initialize Quat)</span>
<span class="sd">    :param n_acq: desired number of acquisition stars (default=8)</span>
<span class="sd">    :param man_angle: maneuver angle (deg)</span>
<span class="sd">    :param t_ccd: ACA CCD temperature (degC)</span>
<span class="sd">    :param date: date of acquisition (any DateTime-compatible format)</span>
<span class="sd">    :param dither: dither size (float or 2-element sequence (dither_y, dither_z), arcsec)</span>
<span class="sd">    :param detector: &#39;ACIS-S&#39; | &#39;ACIS-I&#39; | &#39;HRC-S&#39; | &#39;HRC-I&#39;</span>
<span class="sd">    :param sim_offset: SIM translation offset from nominal [steps] (default=0)</span>
<span class="sd">    :param focus_offset: SIM focus offset [steps] (default=0)</span>
<span class="sd">    :param stars: table of AGASC stars (will be fetched from agasc if None)</span>
<span class="sd">    :param include_ids: list of AGASC IDs of stars to include in selected catalog</span>
<span class="sd">    :param include_halfws: list of acq halfwidths corresponding to ``include_ids``.</span>
<span class="sd">                           For values of ``0`` proseco chooses the best halfwidth(s).</span>
<span class="sd">    :param exclude_ids: list of AGASC IDs of stars to exclude from selected catalog</span>
<span class="sd">    :param optimize: optimize star catalog after initial selection (default=True)</span>
<span class="sd">    :param verbose: provide extra logging info (mostly calc_p_safe) (default=False)</span>
<span class="sd">    :param print_log: print the run log to stdout (default=False)</span>

<span class="sd">    :returns: AcqTable of acquisition stars</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make an empty AcqTable object, mostly for logging.  It gets populated</span>
    <span class="c1"># after selecting initial an inital catalog of potential acq stars.</span>
    <span class="n">acqs</span> <span class="o">=</span> <span class="n">AcqTable</span><span class="p">()</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">set_attrs_from_kwargs</span><span class="p">(</span><span class="n">obsid</span><span class="o">=</span><span class="n">obsid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">set_stars</span><span class="p">()</span>

    <span class="c1"># Only allow imposters that are statistical outliers and are brighter than</span>
    <span class="c1"># this (temperature-dependent) threshold.  See characterisics.py for more</span>
    <span class="c1"># explanation.</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">imposters_mag_limit</span> <span class="o">=</span> <span class="n">snr_mag_for_t_ccd</span><span class="p">(</span>
        <span class="n">acqs</span><span class="o">.</span><span class="n">t_ccd</span><span class="p">,</span>
        <span class="n">ref_mag</span><span class="o">=</span><span class="n">ACQ</span><span class="o">.</span><span class="n">imposter_mag_lim_ref_mag</span><span class="p">,</span>
        <span class="n">ref_t_ccd</span><span class="o">=</span><span class="n">ACQ</span><span class="o">.</span><span class="n">imposter_mag_lim_ref_t_ccd</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">acqs</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;getting dark cal image at date=</span><span class="si">{</span><span class="n">acqs</span><span class="o">.</span><span class="n">date</span><span class="si">}</span><span class="s2"> t_ccd=</span><span class="si">{</span><span class="n">acqs</span><span class="o">.</span><span class="n">t_ccd</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Probability of man_err for this observation with a given man_angle.  Used</span>
    <span class="c1"># for marginalizing probabilities over different man_errs.</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">p_man_errs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">get_p_man_err</span><span class="p">(</span><span class="n">man_err</span><span class="p">,</span> <span class="n">acqs</span><span class="o">.</span><span class="n">man_angle</span><span class="p">)</span> <span class="k">for</span> <span class="n">man_err</span> <span class="ow">in</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">man_errs</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span> <span class="o">=</span> <span class="n">acqs</span><span class="o">.</span><span class="n">get_acq_candidates</span><span class="p">(</span><span class="n">acqs</span><span class="o">.</span><span class="n">stars</span><span class="p">)</span>

    <span class="c1"># Fill in the entire acq[&#39;probs&#39;].p_acqs table (which is actual a dict of keyed by</span>
    <span class="c1"># (box_size, man_err) tuples).</span>
    <span class="k">for</span> <span class="n">acq</span> <span class="ow">in</span> <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span><span class="p">:</span>
        <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;probs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">AcqProbs</span><span class="p">(</span>
            <span class="n">acqs</span><span class="p">,</span> <span class="n">acq</span><span class="p">,</span> <span class="n">acqs</span><span class="o">.</span><span class="n">dither</span><span class="p">,</span> <span class="n">acqs</span><span class="o">.</span><span class="n">stars</span><span class="p">,</span> <span class="n">acqs</span><span class="o">.</span><span class="n">dark</span><span class="p">,</span> <span class="n">acqs</span><span class="o">.</span><span class="n">t_ccd</span><span class="p">,</span> <span class="n">acqs</span><span class="o">.</span><span class="n">date</span>
        <span class="p">)</span>

    <span class="n">acqs</span><span class="o">.</span><span class="n">get_initial_catalog</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">acqs</span><span class="o">.</span><span class="n">optimize</span><span class="p">:</span>
        <span class="n">acqs</span><span class="o">.</span><span class="n">optimize_catalog</span><span class="p">(</span><span class="n">acqs</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># Set p_acq column to be the marginalized probabilities</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">update_p_acq_column</span><span class="p">(</span><span class="n">acqs</span><span class="p">)</span>

    <span class="c1"># Sort to make order match the original candidate list order (by</span>
    <span class="c1"># increasing mag), and assign a slot.  Sadly astropy 3.1 has a real</span>
    <span class="c1"># performance bug here and doing the sort makes 6 deepcopy&#39;s of the</span>
    <span class="c1"># meta, which in this case is substantial (mostly stars).  So temporarily</span>
    <span class="c1"># clear out the meta before sorting and then restore from a (light) copy.</span>
    <span class="n">acqs_meta_copy</span> <span class="o">=</span> <span class="n">acqs</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s2">&quot;idx&quot;</span><span class="p">)</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">acqs_meta_copy</span><span class="p">)</span>

    <span class="n">acqs</span><span class="p">[</span><span class="s2">&quot;slot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">acqs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="c1"># Add slot to cand_acqs table, putting in -99 if not selected as acq.</span>
    <span class="c1"># This is for convenience in downstream reporting or introspection.</span>
    <span class="n">slots</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">acqs</span><span class="o">.</span><span class="n">get_id</span><span class="p">(</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])[</span><span class="s2">&quot;slot&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">acqs</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="o">-</span><span class="mi">99</span>
        <span class="k">for</span> <span class="n">acq</span> <span class="ow">in</span> <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span>
    <span class="p">]</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;slot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slots</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acqs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">acqs</span><span class="o">.</span><span class="n">n_acq</span><span class="p">:</span>
        <span class="n">acqs</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Selected only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">acqs</span><span class="p">)</span><span class="si">}</span><span class="s2"> acq stars versus requested </span><span class="si">{</span><span class="n">acqs</span><span class="o">.</span><span class="n">n_acq</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">warning</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Get the acq prob model info and add to the table.</span>
    <span class="n">acqs</span><span class="o">.</span><span class="n">acq_prob_model_info</span> <span class="o">=</span> <span class="n">get_default_acq_prob_model_info</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">acqs</span></div>



<div class="viewcode-block" id="AcqTable">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable">[docs]</a>
<span class="k">class</span> <span class="nc">AcqTable</span><span class="p">(</span><span class="n">ACACatalogTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Catalog of acquisition stars</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define base set of allowed keyword args to __init__. Subsequent MetaAttribute</span>
    <span class="c1"># or AliasAttribute properties will add to this.</span>
    <span class="n">allowed_kwargs</span> <span class="o">=</span> <span class="n">ACACatalogTable</span><span class="o">.</span><span class="n">allowed_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Catalog type when plotting (None | &#39;FID&#39; | &#39;ACQ&#39; | &#39;GUI&#39;)</span>
    <span class="n">catalog_type</span> <span class="o">=</span> <span class="s2">&quot;ACQ&quot;</span>

    <span class="c1"># Elements of meta that should not be directly serialized to pickle</span>
    <span class="c1"># (either too big or requires special handling).</span>
    <span class="n">pickle_exclude</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;stars&quot;</span><span class="p">,</span> <span class="s2">&quot;dark&quot;</span><span class="p">,</span> <span class="s2">&quot;bad_stars&quot;</span><span class="p">)</span>

    <span class="c1"># Name of table.  Use to define default file names where applicable.</span>
    <span class="c1"># (e.g. `obs19387/acqs.pkl`).</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;acqs&quot;</span>

    <span class="c1"># Required attributes</span>
    <span class="n">required_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;att&quot;</span><span class="p">,</span> <span class="s2">&quot;man_angle&quot;</span><span class="p">,</span> <span class="s2">&quot;t_ccd_acq&quot;</span><span class="p">,</span> <span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;dither_acq&quot;</span><span class="p">)</span>

    <span class="n">t_ccd</span> <span class="o">=</span> <span class="n">AliasAttribute</span><span class="p">()</span>  <span class="c1"># Maps t_ccd to t_ccd_acq base attribute</span>
    <span class="n">dither</span> <span class="o">=</span> <span class="n">AliasAttribute</span><span class="p">()</span>  <span class="c1"># .. and likewise.</span>
    <span class="n">include_ids</span> <span class="o">=</span> <span class="n">AliasAttribute</span><span class="p">()</span>
    <span class="n">include_halfws</span> <span class="o">=</span> <span class="n">AliasAttribute</span><span class="p">()</span>
    <span class="n">exclude_ids</span> <span class="o">=</span> <span class="n">AliasAttribute</span><span class="p">()</span>

    <span class="c1"># IDs that are included but with halfw=0 which implies to optimize halfw</span>
    <span class="c1"># instead of freezing at the provided value.  This attribute is set internally</span>
    <span class="c1"># based on the values of include_halfws.</span>
    <span class="n">include_optimize_halfw_ids</span> <span class="o">=</span> <span class="n">MetaAttribute</span><span class="p">(</span><span class="n">is_kwarg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">())</span>

    <span class="n">p_man_errs</span> <span class="o">=</span> <span class="n">MetaAttribute</span><span class="p">(</span><span class="n">is_kwarg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">cand_acqs</span> <span class="o">=</span> <span class="n">MetaAttribute</span><span class="p">(</span><span class="n">is_kwarg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">p_safe</span> <span class="o">=</span> <span class="n">MetaAttribute</span><span class="p">(</span><span class="n">is_kwarg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">_fid_set</span> <span class="o">=</span> <span class="n">MetaAttribute</span><span class="p">(</span><span class="n">is_kwarg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">())</span>
    <span class="n">imposters_mag_limit</span> <span class="o">=</span> <span class="n">MetaAttribute</span><span class="p">(</span><span class="n">is_kwarg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">20.0</span><span class="p">)</span>
    <span class="n">acq_prob_model_info</span> <span class="o">=</span> <span class="n">MetaAttribute</span><span class="p">(</span><span class="n">is_kwarg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="AcqTable.empty">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.empty">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a minimal ACACatalogTable which satisfies API requirements.  For AcqTable</span>
<span class="sd">        it should have &#39;id&#39; and &#39;halfw&#39; columns.</span>

<span class="sd">        :returns: StarsTable of stars (empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fid_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_fid_set&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fid_set</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fid_set</span>

    <span class="nd">@fid_set</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fid_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid_ids</span><span class="p">):</span>
        <span class="c1"># No action required if fid_set is already fid_ids</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fid_set</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fid_ids</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot set fid_set before setting fids&quot;</span><span class="p">)</span>

        <span class="n">cand_fids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fids</span><span class="o">.</span><span class="n">cand_fids</span>
        <span class="k">if</span> <span class="n">cand_fids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot set fid_set before selecting candidate fids&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fid_set</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">cand_fids_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cand_fids</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">fid_id</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fid_ids</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fid_id</span> <span class="ow">in</span> <span class="n">cand_fids_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fid_set</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fid_id</span><span class="p">,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Fid </span><span class="si">{</span><span class="n">fid_id</span><span class="si">}</span><span class="s2"> is not in available candidate &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;fid ids </span><span class="si">{</span><span class="n">cand_fids_ids</span><span class="si">}</span><span class="s2">, ignoring&quot;</span><span class="p">,</span>
                    <span class="n">warning</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Update marginalized p_acq and p_safe.  The underlying probability</span>
        <span class="c1"># functions know about fid_set and new values are computed on-demand.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_p_acq_column</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_p_safe</span><span class="p">()</span>

<div class="viewcode-block" id="AcqTable.make_report">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.make_report">[docs]</a>
    <span class="k">def</span> <span class="nf">make_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rootdir</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make summary HTML report for acq selection process and outputs.</span>

<span class="sd">        Output is in ``&lt;rootdir&gt;/obs&lt;obsid&gt;/acq/index.html`` plus related images</span>
<span class="sd">        in that directory.</span>

<span class="sd">        :param rootdir: root directory for outputs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.report_acq</span> <span class="kn">import</span> <span class="n">make_report</span>

        <span class="n">make_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rootdir</span><span class="o">=</span><span class="n">rootdir</span><span class="p">)</span></div>


<div class="viewcode-block" id="AcqTable.update_p_acq_column">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.update_p_acq_column">[docs]</a>
    <span class="k">def</span> <span class="nf">update_p_acq_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acqs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update (in-place) the marginalized acquisition probability column</span>
<span class="sd">        &#39;p_acq&#39;.  This is typically called after a change in catalog or</span>
<span class="sd">        change in the fid set.  The acq[&#39;probs&#39;].p_acq_marg() method will</span>
<span class="sd">        pick up the new fid set.</span>
<span class="sd">        :param acqs:</span>
<span class="sd">        :param acqs:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlap_penalties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_overlap_penalties</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">acq</span><span class="p">,</span> <span class="n">overlap_penalty</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overlap_penalties</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;p_acq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;probs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">p_acq_marg</span><span class="p">(</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">],</span> <span class="n">acqs</span><span class="p">)</span> <span class="o">*</span> <span class="n">overlap_penalty</span></div>


<div class="viewcode-block" id="AcqTable.update_idxs_halfws">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.update_idxs_halfws">[docs]</a>
    <span class="k">def</span> <span class="nf">update_idxs_halfws</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">halfws</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the rows of self to match the specified ``agasc_ids``</span>
<span class="sd">        and half widths.  These two input lists must match the length</span>
<span class="sd">        of self and correspond to stars in self.cand_acqs.</span>

<span class="sd">        :param agasc_ids: list of AGASC IDs</span>
<span class="sd">        :param halfws: list of search box half widths</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">halfws</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input lists must match length of acqs&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">acq</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">halfw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">halfws</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;idx&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">:</span>
                <span class="n">acq_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cand_acqs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                    <span class="n">acq</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">acq_new</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">halfw</span></div>


<div class="viewcode-block" id="AcqTable.get_log_p_2_or_fewer">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.get_log_p_2_or_fewer">[docs]</a>
    <span class="k">def</span> <span class="nf">get_log_p_2_or_fewer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the starcheck acquisition merit function of the probability of</span>
<span class="sd">        acquiring two or fewer stars.</span>

<span class="sd">        :returns: log10(probability) (float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_or_fewer_probs</span> <span class="o">=</span> <span class="n">prob_n_acq</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;p_acq&quot;</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_or_fewer_probs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">p_2_or_fewer</span> <span class="o">=</span> <span class="n">n_or_fewer_probs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_2_or_fewer</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">p_2_or_fewer</span><span class="p">)</span></div>


<div class="viewcode-block" id="AcqTable.get_obs_info">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.get_obs_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_obs_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method to return the parts of meta that are needed</span>
<span class="sd">        for test_common OBS_INFO.</span>

<span class="sd">        :returns: dict of observation information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;obsid&quot;</span><span class="p">,</span>
            <span class="s2">&quot;att&quot;</span><span class="p">,</span>
            <span class="s2">&quot;date&quot;</span><span class="p">,</span>
            <span class="s2">&quot;t_ccd_acq&quot;</span><span class="p">,</span>
            <span class="s2">&quot;t_ccd_guide&quot;</span><span class="p">,</span>
            <span class="s2">&quot;man_angle&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dither_acq&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dither_guide&quot;</span><span class="p">,</span>
            <span class="s2">&quot;detector&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sim_offset&quot;</span><span class="p">,</span>
            <span class="s2">&quot;focus_offset&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span></div>


<div class="viewcode-block" id="AcqTable.get_candidates_mask">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.get_candidates_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">get_candidates_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get base filter for acceptable candidates.</span>

<span class="sd">        This does not include spatial filtering.</span>

<span class="sd">        :param stars: StarsTable</span>
<span class="sd">        :returns: bool mask of acceptable stars</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;CLASS&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">5.3</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">11.0</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;COLOR1&quot;</span><span class="p">],</span> <span class="mf">0.7</span><span class="p">))</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;ASPQ1&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">)</span>  <span class="c1"># Mag err &lt; 1.0 mag</span>
            <span class="o">&amp;</span> <span class="p">(</span>  <span class="c1"># Less than 2 arcsec centroid offset due to nearby spoiler</span>
                <span class="n">stars</span><span class="p">[</span><span class="s2">&quot;ASPQ2&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;POS_ERR&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3000</span><span class="p">)</span>  <span class="c1"># Proper motion less than 0.5 arcsec/yr</span>
            <span class="o">&amp;</span> <span class="p">(</span>  <span class="c1"># Position error &lt; 3.0 arcsec</span>
                <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;VAR&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">9999</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;VAR&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># Not known to vary &gt; 0.2 mag</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ok</span></div>


<div class="viewcode-block" id="AcqTable.get_acq_candidates">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.get_acq_candidates">[docs]</a>
    <span class="k">def</span> <span class="nf">get_acq_candidates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">max_candidates</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StarsTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get candidates for acquisition stars from ``stars`` table.</span>

<span class="sd">        This allows for candidates right up to the useful part of the CCD.</span>
<span class="sd">        The p_acq will be accordingly penalized.</span>

<span class="sd">        :param stars: list of stars in the field</span>
<span class="sd">        :param max_candidates: maximum candidate acq stars</span>

<span class="sd">        :returns: Table of candidates, indices of rejected stars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_candidates_mask</span><span class="p">(</span><span class="n">stars</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">ACA</span><span class="o">.</span><span class="n">max_ccd_row</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span>  <span class="c1"># Max usable row</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">ACA</span><span class="o">.</span><span class="n">max_ccd_col</span>
            <span class="p">)</span>  <span class="c1"># Max usable col</span>
        <span class="p">)</span>

        <span class="n">cand_acqs</span> <span class="o">=</span> <span class="n">stars</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>

        <span class="n">cand_acqs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s2">&quot;mag&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="s2">&quot;Filtering on CLASS, mag, COLOR1, row/col, &quot;</span> <span class="s2">&quot;mag_err, ASPQ1/2, POS_ERR:&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Reduced star list from </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">stars</span><span class="p">)</span><span class="si">}</span><span class="s2"> to &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">)</span><span class="si">}</span><span class="s2"> candidate acq stars&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Reject any candidate with a spoiler or bad star.  Collect a list of</span>
        <span class="c1"># good (not rejected) candidates and stop when there are</span>
        <span class="c1"># max_candidates.  Check for col spoilers only against stars that are</span>
        <span class="c1"># bright enough and on CCD</span>
        <span class="n">goods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stars_mask</span> <span class="o">=</span> <span class="n">stars</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">11.5</span> <span class="o">-</span> <span class="n">ACA</span><span class="o">.</span><span class="n">col_spoiler_mag_diff</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">acq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">in_bad_star_set</span><span class="p">(</span><span class="n">acq</span><span class="p">)</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_nearby_spoiler</span><span class="p">(</span><span class="n">acq</span><span class="p">,</span> <span class="n">stars</span><span class="p">)</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_column_spoiler</span><span class="p">(</span><span class="n">acq</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">stars_mask</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">goods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">goods</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_candidates</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">cand_acqs</span> <span class="o">=</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="n">goods</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="s2">&quot;Selected </span><span class="si">{}</span><span class="s2"> candidates with no spoiler (star within 3 mag and 30 arcsec)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># If any include_ids (stars forced to be in catalog) ensure that the</span>
        <span class="c1"># star is in the cand_acqs table.  Need to re-sort as well.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_include_ids</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">,</span> <span class="n">stars</span><span class="p">)</span>
            <span class="n">cand_acqs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s2">&quot;mag&quot;</span><span class="p">)</span>

        <span class="n">cand_acqs</span><span class="o">.</span><span class="n">rename_column</span><span class="p">(</span><span class="s2">&quot;COLOR1&quot;</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">)</span>
        <span class="c1"># Drop all the other AGASC columns.  No longer useful.</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cand_acqs</span><span class="o">.</span><span class="n">colnames</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">isupper</span><span class="p">()]</span>
        <span class="n">cand_acqs</span> <span class="o">=</span> <span class="n">AcqTable</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">[</span><span class="n">names</span><span class="p">])</span>

        <span class="n">box_sizes_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_box_sizes</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">)</span>
        <span class="n">halfws</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">box_sizes</span> <span class="ow">in</span> <span class="n">box_sizes_list</span><span class="p">]</span>

        <span class="c1"># Make this suitable for plotting</span>
        <span class="n">n_cand</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">)</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_cand</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_cand</span><span class="p">,</span> <span class="s2">&quot;ACQ&quot;</span><span class="p">)</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">halfws</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="c1"># Acq prob for box_size=halfw, marginalized over man_err</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;p_acq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_cand</span><span class="p">,</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">)</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;probs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_cand</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># Filled in with AcqProb objects</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;spoilers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="n">n_cand</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">)</span>  <span class="c1"># Filled in with Table of spoilers</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;imposters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="n">n_cand</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">)</span>  <span class="c1"># Filled in with Table of imposters</span>
        <span class="c1"># Cached value of box_size + man_err for spoilers</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;spoilers_box&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_cand</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Cached value of box_size + dither for imposters</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;imposters_box&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_cand</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Need to make an object array to prevent numpy from turning list of</span>
        <span class="c1"># ndarray into a 2-d array.</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;box_sizes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_cand</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;box_sizes&quot;</span><span class="p">][()]</span> <span class="o">=</span> <span class="n">box_sizes_list</span>

        <span class="k">return</span> <span class="n">cand_acqs</span></div>


<div class="viewcode-block" id="AcqTable.get_box_sizes">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.get_box_sizes">[docs]</a>
    <span class="k">def</span> <span class="nf">get_box_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cand_acqs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the available box sizes for each cand_acq as all those with size &lt;= the</span>
<span class="sd">        largest man_error with non-zero probability.  E.g. in the 5-20 deg man</span>
<span class="sd">        angle bin the 80-100&quot; row is 0.1 and the 100-120&quot; row is 0.0.  So this</span>
<span class="sd">        will will limit the box sizes to 60, 80, and 100.</span>

<span class="sd">        An exception to the box size limit is for bright stars.  For stars</span>
<span class="sd">        brighter than 8.0 mag (referenced to t_ccd=-10), the box size is</span>
<span class="sd">        allowed to go up to at least 100 arcsec.  For stars brighter than 9.0</span>
<span class="sd">        mag it can go up to at least 80 arcsec.  At these bright mags the</span>
<span class="sd">        larger search boxes have no impact on acquisition probability.</span>

<span class="sd">        This is particularly relevant to man_angle &lt; 5 deg, where the max</span>
<span class="sd">        maneuver error is 60 arcsec.  In this case, bright stars can still have</span>
<span class="sd">        80 or 100 arcsec boxes.  In the case of a creep-away observation where</span>
<span class="sd">        the initial bias might be bad, this gives a bit more margin.</span>

<span class="sd">        :param cand_acqs: AcqTable of candidate acq stars</span>
<span class="sd">        :return: list of box-size arrays corresponding to cand_acqs table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">box_sizes_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_man_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ACQ</span><span class="o">.</span><span class="n">man_errs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">p_man_errs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Get the effective equivalent of 8.0 and 9.0 mag for the current t_ccd</span>
        <span class="n">mag_8</span> <span class="o">=</span> <span class="n">snr_mag_for_t_ccd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_ccd</span><span class="p">,</span> <span class="n">ref_mag</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span> <span class="n">ref_t_ccd</span><span class="o">=-</span><span class="mf">10.0</span><span class="p">)</span>
        <span class="n">mag_9</span> <span class="o">=</span> <span class="n">snr_mag_for_t_ccd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_ccd</span><span class="p">,</span> <span class="n">ref_mag</span><span class="o">=</span><span class="mf">9.0</span><span class="p">,</span> <span class="n">ref_t_ccd</span><span class="o">=-</span><span class="mf">10.0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cand_acq</span> <span class="ow">in</span> <span class="n">cand_acqs</span><span class="p">:</span>
            <span class="n">mag</span> <span class="o">=</span> <span class="n">cand_acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mag</span> <span class="o">&lt;</span> <span class="n">mag_8</span><span class="p">:</span>
                <span class="n">max_box_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_man_err</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mag</span> <span class="o">&lt;</span> <span class="n">mag_9</span><span class="p">:</span>
                <span class="n">max_box_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_man_err</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_box_size</span> <span class="o">=</span> <span class="n">max_man_err</span>
            <span class="n">box_sizes</span> <span class="o">=</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">box_sizes</span><span class="p">[</span><span class="n">ACQ</span><span class="o">.</span><span class="n">box_sizes</span> <span class="o">&lt;=</span> <span class="n">max_box_size</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;PROSECO_IGNORE_MAXMAGS_CONSTRAINTS&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
                <span class="n">box_sizes_new</span> <span class="o">=</span> <span class="n">filter_box_sizes_for_maxmag</span><span class="p">(</span>
                    <span class="n">cand_acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">],</span> <span class="n">cand_acq</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">],</span> <span class="n">box_sizes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_ccd</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">box_sizes_filtered</span> <span class="o">:=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">box_sizes</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">box_sizes_new</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;id=</span><span class="si">{</span><span class="n">cand_acq</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: filtered </span><span class="si">{</span><span class="n">box_sizes_filtered</span><span class="si">}</span><span class="s2"> boxes &quot;</span>
                        <span class="s2">&quot;for maxmag constraints&quot;</span>
                    <span class="p">)</span>
                    <span class="n">box_sizes</span> <span class="o">=</span> <span class="n">box_sizes_new</span>
            <span class="n">box_sizes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box_sizes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">box_sizes_list</span></div>


<div class="viewcode-block" id="AcqTable.in_bad_star_set">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.in_bad_star_set">[docs]</a>
    <span class="k">def</span> <span class="nf">in_bad_star_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if ``acq`` is in the bad star set.</span>

<span class="sd">        :param acq: AcqTable Row</span>
<span class="sd">        :returns: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">ACA</span><span class="o">.</span><span class="n">bad_star_set</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Rejecting star </span><span class="si">{</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> which is in bad star list&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stars</span><span class="o">.</span><span class="n">get_id_idx</span><span class="p">(</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bad_stars_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="AcqTable.has_nearby_spoiler">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.has_nearby_spoiler">[docs]</a>
    <span class="k">def</span> <span class="nf">has_nearby_spoiler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acq</span><span class="p">,</span> <span class="n">stars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if ``acq`` has a nearby star that could spoil acquisition.</span>

<span class="sd">        :param acq: AcqTable Row</span>
<span class="sd">        :param stars: StarsTable</span>
<span class="sd">        :returns: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;ASPQ1&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="n">frac_norm</span> <span class="o">=</span> <span class="n">calc_spoiler_impact</span><span class="p">(</span><span class="n">acq</span><span class="p">,</span> <span class="n">stars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="ow">or</span> <span class="n">frac_norm</span> <span class="o">&lt;</span> <span class="mf">0.95</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Candidate acq star </span><span class="si">{</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> rejected due to nearby spoiler(s) &#39;</span>
                <span class="sa">f</span><span class="s2">&quot;dy=</span><span class="si">{</span><span class="n">dy</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> dz=</span><span class="si">{</span><span class="n">dz</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> frac_norm=</span><span class="si">{</span><span class="n">frac_norm</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="AcqTable.process_include_ids">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.process_include_ids">[docs]</a>
    <span class="k">def</span> <span class="nf">process_include_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cand_acqs</span><span class="p">,</span> <span class="n">stars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure that the cand_acqs table has stars that were forced to be included.</span>

<span class="sd">        Also do validation of include_ids and include_halfws.</span>

<span class="sd">        :param cand_acqs: candidate acquisition stars table</span>
<span class="sd">        :param stars: stars table</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Allow for not providing halfws, in which case proseco chooses.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;include_ids and include_halfws must have same length&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure values are valid box_sizes</span>
        <span class="n">grid_func</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
            <span class="n">ACQ</span><span class="o">.</span><span class="n">box_sizes</span><span class="p">,</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">box_sizes</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_optimize_halfw_ids</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">acq_id</span>
            <span class="k">for</span> <span class="n">acq_id</span><span class="p">,</span> <span class="n">halfw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">halfw</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span> <span class="o">=</span> <span class="n">grid_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">process_include_ids</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">,</span> <span class="n">stars</span><span class="p">)</span></div>


<div class="viewcode-block" id="AcqTable.select_best_p_acqs">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.select_best_p_acqs">[docs]</a>
    <span class="k">def</span> <span class="nf">select_best_p_acqs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cand_acqs</span><span class="p">,</span> <span class="n">min_p_acq</span><span class="p">,</span> <span class="n">acq_indices</span><span class="p">,</span> <span class="n">box_sizes</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find stars with the highest acquisition probability according to the</span>
<span class="sd">        algorithm below.  ``p_acqs`` is the same-named column from candidate</span>
<span class="sd">        acq stars and it contains a dict keyed by (box_size, man_err).  This</span>
<span class="sd">        algorithm uses the assumption of man_err=box_size.</span>

<span class="sd">        - Loop over box sizes in descending order (160, ..., 60)</span>
<span class="sd">        - Sort in descending order the p_acqs corresponding to that box size</span>
<span class="sd">          (where largest p_acqs come first)</span>
<span class="sd">        - Loop over the list and add any stars with p_acq &gt; min_p_acq to the</span>
<span class="sd">          list of accepted stars.</span>
<span class="sd">        - If the list is ``n_acq`` long (completely catalog) then stop</span>

<span class="sd">        This function can be called multiple times with successively smaller</span>
<span class="sd">        min_p_acq to fill out the catalog.  The acq_indices and box_sizes</span>
<span class="sd">        arrays are appended in place in this process.</span>

<span class="sd">        :param cand_acqs: AcqTable of candidate acquisition stars</span>
<span class="sd">        :param min_p_acq: minimum p_acq to include in this round (float)</span>
<span class="sd">        :param acq_indices: list of indices into cand_acqs of selected stars</span>
<span class="sd">        :param box_sizes: list of box sizes of selected stars</span>
<span class="sd">        :param force: force-include stars (default=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Find stars with best acq prob for min_p_acq=</span><span class="si">{</span><span class="n">min_p_acq</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current catalog: acq_indices=</span><span class="si">{</span><span class="n">acq_indices</span><span class="si">}</span><span class="s2"> box_sizes=</span><span class="si">{</span><span class="n">box_sizes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">box_size</span> <span class="ow">in</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">box_sizes</span><span class="p">:</span>
            <span class="c1"># Get array of marginalized (over man_err) p_acq values corresponding</span>
            <span class="c1"># to box_size for each of the candidate acq stars.  For acq&#39;s where</span>
            <span class="c1"># the current box_size is not in the available list then set the</span>
            <span class="c1"># probability to zero.  This happens for small maneuver angles where</span>
            <span class="c1"># acq.box_sizes might be only [60] or [60, 80].</span>
            <span class="n">p_acqs_for_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">))</span>
            <span class="n">my_box_sizes</span> <span class="o">=</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;box_sizes&quot;</span><span class="p">]</span>
            <span class="n">my_probs</span> <span class="o">=</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;probs&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">box_size</span> <span class="ow">in</span> <span class="n">my_box_sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="n">p_acqs_for_box</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_probs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">p_acq_marg</span><span class="p">(</span><span class="n">box_size</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying search box size </span><span class="si">{</span><span class="n">box_size</span><span class="si">}</span><span class="s2"> arcsec&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p_acqs_for_box</span> <span class="o">&lt;</span> <span class="n">min_p_acq</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;No acceptable candidates (probably small man angle)&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">p_acqs_for_box</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">acq_idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">acq_idx</span> <span class="ow">in</span> <span class="n">acq_indices</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">acq</span> <span class="o">=</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="n">acq_idx</span><span class="p">]</span>

                <span class="c1"># Don&#39;t consider any stars in the exclude list</span>
                <span class="k">if</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude_ids</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># If acq and box size overlaps box of already selected star then skip.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">overlap_id</span> <span class="o">:=</span> <span class="n">boxes_overlap</span><span class="p">(</span>
                        <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;yang&quot;</span><span class="p">],</span>
                        <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;zang&quot;</span><span class="p">],</span>
                        <span class="n">box_size</span><span class="p">,</span>
                        <span class="n">cand_acqs</span><span class="p">,</span>
                        <span class="n">box_sizes</span><span class="p">,</span>
                        <span class="n">acq_indices</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Skipping star </span><span class="si">{</span><span class="n">acq_idx</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2"> box </span><span class="si">{</span><span class="n">box_size</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;overlaps with selected star </span><span class="si">{</span><span class="n">overlap_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">p_acq</span> <span class="o">=</span> <span class="n">p_acqs_for_box</span><span class="p">[</span><span class="n">acq_idx</span><span class="p">]</span>
                <span class="n">accepted</span> <span class="o">=</span> <span class="n">p_acq</span> <span class="o">&gt;</span> <span class="n">min_p_acq</span>
                <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;ACCEPTED&quot;</span> <span class="k">if</span> <span class="n">accepted</span> <span class="k">else</span> <span class="s2">&quot;rejected&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Star idx=</span><span class="si">{</span><span class="n">acq_idx</span><span class="si">:</span><span class="s1">2d</span><span class="si">}</span><span class="s1"> id=</span><span class="si">{</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">10d</span><span class="si">}</span><span class="s1"> &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;box=</span><span class="si">{</span><span class="n">box_size</span><span class="si">:</span><span class="s1">3d</span><span class="si">}</span><span class="s1"> mag=</span><span class="si">{</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span><span class="si">:</span><span class="s1">5.1f</span><span class="si">}</span><span class="s1"> p_acq=</span><span class="si">{</span><span class="n">p_acq</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> &#39;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="nb">id</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
                    <span class="n">level</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">accepted</span><span class="p">:</span>
                    <span class="n">acq_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acq_idx</span><span class="p">)</span>
                    <span class="n">box_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box_size</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_indices</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_acq</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_acq</span><span class="si">}</span><span class="s2"> acq stars, done&quot;</span><span class="p">)</span>
                    <span class="k">return</span></div>


<div class="viewcode-block" id="AcqTable.get_initial_catalog">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.get_initial_catalog">[docs]</a>
    <span class="k">def</span> <span class="nf">get_initial_catalog</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the initial catalog of up to ``n_acq`` candidate acquisition stars.  This</span>
<span class="sd">        updates the current AcqTable (self) in place to add selected stars.</span>

<span class="sd">        TO DO: these should all just be taken from self</span>

<span class="sd">        :param cand_acqs: AcqTable of candidate acquisition stars</span>
<span class="sd">        :param stars: StarsTable of stars in or near the ACA FOV</span>
<span class="sd">        :param dark: dark current image (ndarray, e-/sec)</span>
<span class="sd">        :param dither: dither (float, arcsec)</span>
<span class="sd">        :param t_ccd: CCD temperature (float, degC)</span>
<span class="sd">        :param date: observation date</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cand_acqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cand_acqs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting initial catalog from </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">)</span><span class="si">}</span><span class="s2"> candidates&quot;</span><span class="p">)</span>

        <span class="c1"># Build up the initial catalog as a list of indices into cand_acqs</span>
        <span class="c1"># and the corresponding initial box size (halfw).</span>
        <span class="n">acq_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">box_sizes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Start with force-include stars, if any.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Processing force-include ids=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;halfws=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Re-order candidate acqs to put those in the include list first</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="p">)</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ok</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">ok</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">cand_acqs</span> <span class="o">=</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>

            <span class="n">n_include</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">min_p_acq</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_include</span><span class="p">:</span>
                    <span class="c1"># Select candidates meeting min_p_acq, and update</span>
                    <span class="c1"># acq_indices, box_sizes in place</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">select_best_p_acqs</span><span class="p">(</span>
                        <span class="n">cand_acqs</span><span class="p">[:</span><span class="n">n_include</span><span class="p">],</span>
                        <span class="n">min_p_acq</span><span class="p">,</span>
                        <span class="n">acq_indices</span><span class="p">,</span>
                        <span class="n">box_sizes</span><span class="p">,</span>
                        <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># This should never happen but be careful</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_indices</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_include</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;failure in force-include&quot;</span><span class="p">)</span>

            <span class="c1"># For include stars where the halfw is not going to be optimized</span>
            <span class="c1"># then then override the box size that was just found with the</span>
            <span class="c1"># user-supplied value.</span>
            <span class="k">for</span> <span class="n">include_id</span><span class="p">,</span> <span class="n">include_halfw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_halfws</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">include_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_optimize_halfw_ids</span><span class="p">:</span>
                    <span class="c1"># Find the position in box_sizes that corresponds to include_id</span>
                    <span class="c1"># and set to the specified include_halfw.</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">acq_indices</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">include_id</span> <span class="o">==</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="n">acq_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]][</span><span class="s2">&quot;id&quot;</span><span class="p">]:</span>
                            <span class="n">box_sizes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">include_halfw</span>
                            <span class="k">break</span>

        <span class="c1"># Now accumulate indices and box sizes of candidate acq stars that meet</span>
        <span class="c1"># successively less stringent minimum p_acq.</span>
        <span class="k">for</span> <span class="n">min_p_acq</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_acq</span><span class="p">:</span>
                <span class="c1"># Updates acq_indices, box_sizes in place</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">select_best_p_acqs</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">,</span> <span class="n">min_p_acq</span><span class="p">,</span> <span class="n">acq_indices</span><span class="p">,</span> <span class="n">box_sizes</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acq_indices</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_acq</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Make all the not-accepted candidate acqs have halfw=120 as a reasonable</span>
        <span class="c1"># default and then set the accepted acqs to the best box_size.  Then set</span>
        <span class="c1"># p_acq to the marginalized acquisition probability.</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">])</span>
        <span class="n">cand_acqs</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">][</span><span class="n">acq_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_sizes</span>
        <span class="n">cand_acqs</span><span class="o">.</span><span class="n">update_p_acq_column</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Finally select the initial catalog</span>
        <span class="n">acqs_init</span> <span class="o">=</span> <span class="n">cand_acqs</span><span class="p">[</span><span class="n">acq_indices</span><span class="p">]</span>

        <span class="c1"># Transfer to acqs (which at this point is an empty table)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">acqs_init</span><span class="o">.</span><span class="n">itercols</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span></div>


<div class="viewcode-block" id="AcqTable.calc_p_brightest">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.calc_p_brightest">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_p_brightest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acq</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bgd</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the probability that the `acq` star is the brightest</span>
<span class="sd">        candidate in the search box.</span>

<span class="sd">        This caches the spoiler and imposter stars in the acqs table (the row</span>
<span class="sd">        corresponding to ``acq``).  It is required that the first time this is</span>
<span class="sd">        called that the box_size and man_err be the maximum, and this is checked.</span>

<span class="sd">        :param acq: acq stars (AcqTable Row)</span>
<span class="sd">        :param box_size: box size (float, arcsec)</span>
<span class="sd">        :param man_err: maneuver error (float, arcsec, default=0)</span>
<span class="sd">        :param bgd: assume background for imposters (float, e-sec, default=0)</span>

<span class="sd">        :returns: probability that acq is the brightest (float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stars</span>
        <span class="n">dark</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dark</span>
        <span class="n">dither</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dither</span>

        <span class="c1"># Spoilers</span>
        <span class="n">ext_box_size</span> <span class="o">=</span> <span class="n">box_size</span> <span class="o">+</span> <span class="n">man_err</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stars</span><span class="o">=</span><span class="n">stars</span><span class="p">,</span> <span class="n">acq</span><span class="o">=</span><span class="n">acq</span><span class="p">,</span> <span class="n">box_size</span><span class="o">=</span><span class="n">ext_box_size</span><span class="p">)</span>
        <span class="n">spoilers</span> <span class="o">=</span> <span class="n">get_intruders</span><span class="p">(</span>
            <span class="n">acq</span><span class="p">,</span>
            <span class="n">ext_box_size</span><span class="p">,</span>
            <span class="s2">&quot;spoilers&quot;</span><span class="p">,</span>
            <span class="n">n_sigma</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>  <span class="c1"># TO DO: put to characteristics</span>
            <span class="n">get_func</span><span class="o">=</span><span class="n">get_spoiler_stars</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Imposters</span>
        <span class="n">ext_box_size</span> <span class="o">=</span> <span class="n">box_size</span> <span class="o">+</span> <span class="n">dither</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">star_row</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">],</span>
            <span class="n">star_col</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">],</span>
            <span class="n">maxmag</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">],</span>
            <span class="n">box_size</span><span class="o">=</span><span class="n">ext_box_size</span><span class="p">,</span>
            <span class="n">dark</span><span class="o">=</span><span class="n">dark</span><span class="p">,</span>
            <span class="n">bgd</span><span class="o">=</span><span class="n">bgd</span><span class="p">,</span>  <span class="c1"># TO DO deal with this</span>
            <span class="n">mag_limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">imposters_mag_limit</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">imposters</span> <span class="o">=</span> <span class="n">get_intruders</span><span class="p">(</span>
            <span class="n">acq</span><span class="p">,</span>
            <span class="n">ext_box_size</span><span class="p">,</span>
            <span class="s2">&quot;imposters&quot;</span><span class="p">,</span>
            <span class="n">n_sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># TO DO: put to characteristics</span>
            <span class="n">get_func</span><span class="o">=</span><span class="n">get_imposter_stars</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">mags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">spoilers</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">],</span> <span class="n">imposters</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]])</span>
        <span class="n">mag_errs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">spoilers</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">],</span> <span class="n">imposters</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">]])</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">calc_p_brightest_compare</span><span class="p">(</span><span class="n">acq</span><span class="p">,</span> <span class="n">mags</span><span class="p">,</span> <span class="n">mag_errs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">prob</span></div>


<div class="viewcode-block" id="AcqTable.get_overlap_penalties">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.get_overlap_penalties">[docs]</a>
    <span class="k">def</span> <span class="nf">get_overlap_penalties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the probability penalties for overlapping boxes.</span>

<span class="sd">        This is returned as a multiplicative factor on the acquisition success</span>
<span class="sd">        probability. No overlap penalty implies a value of 1.0.</span>

<span class="sd">        :returns: list of penalties (float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_acq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">penalties</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_acq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PROSECO_DISABLE_OVERLAP_PENALTY&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">penalties</span>

        <span class="n">mags</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">halfws</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">yangs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;yang&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">zangs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;zang&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="k">for</span> <span class="n">idx1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_acq</span><span class="p">):</span>
            <span class="n">mag1</span> <span class="o">=</span> <span class="n">mags</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">halfw1</span> <span class="o">=</span> <span class="n">halfws</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">yang1</span> <span class="o">=</span> <span class="n">yangs</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
            <span class="n">zang1</span> <span class="o">=</span> <span class="n">zangs</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_acq</span><span class="p">):</span>
                <span class="n">mag2</span> <span class="o">=</span> <span class="n">mags</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
                <span class="n">halfw2</span> <span class="o">=</span> <span class="n">halfws</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
                <span class="n">yang2</span> <span class="o">=</span> <span class="n">yangs</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
                <span class="n">zang2</span> <span class="o">=</span> <span class="n">zangs</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">box_overlap</span><span class="p">(</span><span class="n">yang1</span><span class="p">,</span> <span class="n">zang1</span><span class="p">,</span> <span class="n">halfw1</span><span class="p">,</span> <span class="n">yang2</span><span class="p">,</span> <span class="n">zang2</span><span class="p">,</span> <span class="n">halfw2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">mag1</span> <span class="o">+</span> <span class="n">OVERLAP_MAG_DEADBAND</span> <span class="o">&lt;</span> <span class="n">mag2</span><span class="p">:</span>
                        <span class="c1"># Star 1 is at least 0.2 mag brighter than star 2</span>
                        <span class="n">penalties</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">=</span> <span class="n">OVERLAP_P_ACQ_PENALTY</span>
                    <span class="k">elif</span> <span class="n">mag2</span> <span class="o">+</span> <span class="n">OVERLAP_MAG_DEADBAND</span> <span class="o">&lt;</span> <span class="n">mag1</span><span class="p">:</span>
                        <span class="n">penalties</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">OVERLAP_P_ACQ_PENALTY</span>

        <span class="k">return</span> <span class="n">penalties</span></div>


<div class="viewcode-block" id="AcqTable.calc_p_safe">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.calc_p_safe">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_p_safe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the probability of a safing action resulting from failure</span>
<span class="sd">        to acquire at least two (2) acquisition stars.</span>

<span class="sd">        This uses the probability of 2 or fewer stars =&gt; &quot;conservative&quot; p_fail at this</span>
<span class="sd">        man_err.  This uses 2 stars instead of 1 or fewer (which is the actual criteria</span>
<span class="sd">        for a safing action).  This allows for one star to be dropped for reasons not</span>
<span class="sd">        reflected in the acq model probability and makes the optimization dig a bit deeper</span>
<span class="sd">        in to the catalog beyond the brightest stars.</span>

<span class="sd">        :returns: p_safe (float)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p_no_safe</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">self_halfws</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span>
        <span class="n">self_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;probs&quot;</span><span class="p">]</span>
        <span class="n">overlap_penalties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_overlap_penalties</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">man_err</span><span class="p">,</span> <span class="n">p_man_err</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ACQ</span><span class="o">.</span><span class="n">man_errs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_man_errs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p_man_err</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">p_acqs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">prob</span><span class="o">.</span><span class="n">p_acqs</span><span class="p">(</span><span class="n">halfw</span><span class="p">,</span> <span class="n">man_err</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="o">*</span> <span class="n">overlap_penalty</span>
                <span class="k">for</span> <span class="n">halfw</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">overlap_penalty</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">self_halfws</span><span class="p">,</span> <span class="n">self_probs</span><span class="p">,</span> <span class="n">overlap_penalties</span>
                <span class="p">)</span>
            <span class="p">]</span>

            <span class="n">p_n_cum</span> <span class="o">=</span> <span class="n">prob_n_acq</span><span class="p">(</span><span class="n">p_acqs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># This returns (p_n, p_n_cum)</span>

            <span class="c1"># Probability of 2 or fewer stars =&gt; conservative fail criteria</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p_n_cum</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;man_err = </span><span class="si">{</span><span class="n">man_err</span><span class="si">}</span><span class="s2">, p_man_err = </span><span class="si">{</span><span class="n">p_man_err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="s2">&quot;p_acqs =&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">p_acqs</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;log10(p 2_or_fewer) = </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">p2</span><span class="p">)))</span>

            <span class="n">p_no_safe</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_man_err</span> <span class="o">*</span> <span class="n">p2</span>

        <span class="n">p_safe</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_no_safe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_safe</span> <span class="o">=</span> <span class="n">p_safe</span>

        <span class="k">return</span> <span class="n">p_safe</span></div>


<div class="viewcode-block" id="AcqTable.optimize_acq_halfw">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.optimize_acq_halfw">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize_acq_halfw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p_safe</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the box size (halfw) for the acq star ``idx`` in the current acqs</span>
<span class="sd">        table.  Assume current ``p_safe``.</span>

<span class="sd">        :param idx: acq star index</span>
<span class="sd">        :param p_safe: current value of p_safe</span>
<span class="sd">        :param verbose: include extra information in the run log</span>
<span class="sd">        :returns improved, p_safe: whether p_safe was improved and the new value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">acq</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">orig_halfw</span> <span class="o">=</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span>
        <span class="n">orig_p_acq</span> <span class="o">=</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;probs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">p_acq_marg</span><span class="p">(</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Optimizing halfw for idx=</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1"> id=</span><span class="si">{</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

        <span class="c1"># Compute p_safe for each possible halfw for the current star</span>
        <span class="n">p_safes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">box_sizes</span> <span class="o">=</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;box_sizes&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">box_size</span> <span class="ow">in</span> <span class="n">box_sizes</span><span class="p">:</span>
            <span class="n">new_p_acq</span> <span class="o">=</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;probs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">p_acq_marg</span><span class="p">(</span><span class="n">box_size</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="c1"># Do not reduce marginalized p_acq to below 0.1.  It can happen that p_safe</span>
            <span class="c1"># goes down very slightly with an increase in box size from the original,</span>
            <span class="c1"># and then the box size gets stuck there because of the deadband for later</span>
            <span class="c1"># reducing box size.</span>
            <span class="k">if</span> <span class="n">new_p_acq</span> <span class="o">&lt;</span> <span class="mf">0.1</span> <span class="ow">and</span> <span class="n">new_p_acq</span> <span class="o">&lt;</span> <span class="n">orig_p_acq</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Skipping halfw </span><span class="si">{</span><span class="n">box_size</span><span class="si">}</span><span class="s2">: new marg p_acq &lt; 0.1 and new &lt; orig&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">new_p_acq</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> &lt; </span><span class="si">{</span><span class="n">orig_p_acq</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
                <span class="n">p_safes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_safe</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_size</span>
                <span class="n">p_safes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_p_safe</span><span class="p">(</span><span class="n">verbose</span><span class="p">))</span>

        <span class="c1"># Find best p_safe</span>
        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">p_safes</span><span class="p">)</span>
        <span class="n">min_p_safe</span> <span class="o">=</span> <span class="n">p_safes</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
        <span class="n">min_halfw</span> <span class="o">=</span> <span class="n">box_sizes</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>

        <span class="c1"># If p_safe went down, then consider this an improvement if either:</span>
        <span class="c1">#   - acq halfw is increased (bigger boxes are better)</span>
        <span class="c1">#   - p_safe went down by at least 10%</span>
        <span class="c1"># So avoid reducing box sizes for only small improvements in p_safe.</span>
        <span class="n">improved</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_p_safe</span> <span class="o">&lt;</span> <span class="n">p_safe</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">min_halfw</span> <span class="o">&gt;</span> <span class="n">orig_halfw</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">min_p_safe</span> <span class="o">/</span> <span class="n">p_safe</span> <span class="o">&lt;</span> <span class="mf">0.9</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">p_safes_strs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">box_size</span><span class="si">}</span><span class="s1">&quot;)&#39;</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">box_size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p_safes</span><span class="p">,</span> <span class="n">box_sizes</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;p_safes=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p_safes_strs</span><span class="p">)),</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="s2">&quot;min_p_safe=</span><span class="si">{:.2f}</span><span class="s2"> p_safe=</span><span class="si">{:.2f}</span><span class="s2"> min_halfw=</span><span class="si">{}</span><span class="s2"> orig_halfw=</span><span class="si">{}</span><span class="s2"> improved=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">min_p_safe</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">p_safe</span><span class="p">),</span> <span class="n">min_halfw</span><span class="p">,</span> <span class="n">orig_halfw</span><span class="p">,</span> <span class="n">improved</span>
            <span class="p">),</span>
            <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">improved</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Update acq idx=</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> halfw from </span><span class="si">{</span><span class="n">orig_halfw</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">min_halfw</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">p_safe</span> <span class="o">=</span> <span class="n">min_p_safe</span>
            <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_halfw</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_halfw</span>

        <span class="k">return</span> <span class="n">p_safe</span><span class="p">,</span> <span class="n">improved</span></div>


<div class="viewcode-block" id="AcqTable.optimize_acqs_halfw">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.optimize_acqs_halfw">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize_acqs_halfw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the box_size (halfw) for the acq stars in the current catalog.</span>
<span class="sd">        This cycles through each star and optimizes the box size for that star</span>
<span class="sd">        using the ``optimize_acq_halfw()`` method.</span>

<span class="sd">        :param verbose: include additional information in the run log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_safe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_p_safe</span><span class="p">()</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;p_acq&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

        <span class="c1"># Any updates made?</span>
        <span class="n">any_improved</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
            <span class="c1"># Don&#39;t optimize halfw for a star that is specified for inclusion</span>
            <span class="c1"># with a valid (non-zero) halfw set.  The set of include_optimize_halfw_ids is</span>
            <span class="c1"># any ids where halfw=0 was provided.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">include_optimize_halfw_ids</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">p_safe</span><span class="p">,</span> <span class="n">improved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_acq_halfw</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">p_safe</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
            <span class="n">any_improved</span> <span class="o">|=</span> <span class="n">improved</span>

        <span class="k">return</span> <span class="n">p_safe</span><span class="p">,</span> <span class="n">any_improved</span></div>


<div class="viewcode-block" id="AcqTable.optimize_catalog">
<a class="viewcode-back" href="../../api.html#proseco.acq.AcqTable.optimize_catalog">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize_catalog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the current acquisition catalog.</span>

<span class="sd">        :param verbose: include additional information in the run log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If every acq star is specified as included, then no optimization</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span> <span class="k">for</span> <span class="n">acq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">p_safe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_p_safe</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;initial log10(p_safe)=</span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">p_safe</span><span class="p">)))</span>

        <span class="c1"># Start by optimizing the half-widths of the initial catalog</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">p_safe</span><span class="p">,</span> <span class="n">improved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_acqs_halfw</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">improved</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After optimizing initial catalog p_safe = </span><span class="si">{</span><span class="n">p_safe</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Now try to swap in a new star from the candidate list and see if</span>
        <span class="c1"># it can improve p_safe.  Skips candidates already in the catalog</span>
        <span class="c1"># or specifically excluded.</span>
        <span class="n">skip_acq_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exclude_ids</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cand_acq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cand_acqs</span><span class="p">:</span>
            <span class="n">cand_id</span> <span class="o">=</span> <span class="n">cand_acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cand_id</span> <span class="ow">in</span> <span class="n">skip_acq_ids</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get the index of the worst p_acq in the catalog, excluding acq stars</span>
            <span class="c1"># that are in include_ids (since they are not to be replaced).</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="p">[</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_ids</span> <span class="k">for</span> <span class="n">acq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
            <span class="c1"># acqs = self[ok]</span>
            <span class="n">acqs_probs_ok</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;probs&quot;</span><span class="p">][</span><span class="n">ok</span><span class="p">]</span>
            <span class="n">acqs_halfw_ok</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">][</span><span class="n">ok</span><span class="p">]</span>
            <span class="n">acqs_id_ok</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][</span><span class="n">ok</span><span class="p">]</span>

            <span class="c1"># Sort by the marginalized acq probability for the current box size</span>
            <span class="n">p_acqs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">acq_probs</span><span class="o">.</span><span class="n">p_acq_marg</span><span class="p">(</span><span class="n">acq_halfw</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">acq_probs</span><span class="p">,</span> <span class="n">acq_halfw</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">acqs_probs_ok</span><span class="p">,</span> <span class="n">acqs_halfw_ok</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="c1"># TODO: performance?</span>
            <span class="n">idx_worst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">p_acqs</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_id_idx</span><span class="p">(</span><span class="n">acqs_id_ok</span><span class="p">[</span><span class="n">idx_worst</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="s2">&quot;Trying to use </span><span class="si">{}</span><span class="s2"> mag=</span><span class="si">{:.2f}</span><span class="s2"> to replace idx=</span><span class="si">{}</span><span class="s2"> with p_acq=</span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">cand_id</span><span class="p">,</span> <span class="n">cand_acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">],</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p_acqs</span><span class="p">[</span><span class="n">idx_worst</span><span class="p">]</span>
                <span class="p">),</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">cand_id</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Make a copy of the row (acq star) as a numpy void (structured array row)</span>
            <span class="n">orig_acq</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">as_void</span><span class="p">()</span>

            <span class="c1"># Stub in the new candidate and get the best halfw (and corresponding new p_safe)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand_acq</span>
            <span class="n">new_p_safe</span><span class="p">,</span> <span class="n">improved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_acq_halfw</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">p_safe</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

            <span class="c1"># If the new star is noticably better (regardless of box size), OR</span>
            <span class="c1"># comparable but with a bigger box, then accept it and do one round of</span>
            <span class="c1"># full catalog box-size optimization.</span>
            <span class="n">improved</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_p_safe</span> <span class="o">/</span> <span class="n">p_safe</span> <span class="o">&lt;</span> <span class="mf">0.9</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">new_p_safe</span> <span class="o">&lt;</span> <span class="n">p_safe</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">orig_acq</span><span class="p">[</span><span class="s2">&quot;halfw&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">improved</span><span class="p">:</span>
                <span class="n">p_safe</span><span class="p">,</span> <span class="n">improved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize_acqs_halfw</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calc_p_safe</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  accepted, new p_safe = </span><span class="si">{</span><span class="n">p_safe</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">cand_id</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_acq</span></div>
</div>



<div class="viewcode-block" id="get_spoiler_stars">
<a class="viewcode-back" href="../../api.html#proseco.acq.get_spoiler_stars">[docs]</a>
<span class="k">def</span> <span class="nf">get_spoiler_stars</span><span class="p">(</span><span class="n">stars</span><span class="p">,</span> <span class="n">acq</span><span class="p">,</span> <span class="n">box_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get acq spoiler stars, i.e. any star in the specified box_size (which</span>
<span class="sd">    would normally be an extended box including man_err).</span>

<span class="sd">    OBC adjusts search box position based on the difference between estimated</span>
<span class="sd">    and target attitude (which is the basis for yang/zang in catalog).  Dither</span>
<span class="sd">    is included in the adjustment, so the only remaining term is the</span>
<span class="sd">    maneuver error, which is included via the ``man_err`` box extension.</span>
<span class="sd">    Imagine a 500 arcsec dither pattern.  OBC adjusts search box for that,</span>
<span class="sd">    so apart from actual man err the box will be centered on the acq star.</span>

<span class="sd">    See this ref for information on how well the catalog mag errors correlate</span>
<span class="sd">    with observed.  Answer: not exactly, but probably good enough.  Plots all</span>
<span class="sd">    the way at the bottom are key::</span>

<span class="sd">      http://nbviewer.jupyter.org/url/cxc.harvard.edu/mta/ASPECT/</span>
<span class="sd">             ipynb/ssawg/2018x03x21/star-mag-uncertainties.ipynb</span>

<span class="sd">    TO DO: consider mag uncertainties at the faint end related to</span>
<span class="sd">    background subtraction and warm pixel corruption of background.</span>

<span class="sd">    :param stars: StarsTable of stars for this field</span>
<span class="sd">    :param acq: acquisition star (AcqTable Row)</span>
<span class="sd">    :param box_size: box size (float, arcsec)</span>

<span class="sd">    :returns: numpy structured array of spoiler stars</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stars</span> <span class="o">=</span> <span class="n">stars</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>
    <span class="c1"># 1-sigma of difference of stars[&#39;mag&#39;] - acq[&#39;mag&#39;]</span>
    <span class="c1"># TO DO: lower limit clip?</span>
    <span class="n">mag_diff_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Stars in extended box and within 3-sigma (99.7%)</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;yang&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;yang&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">box_size</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;zang&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;zang&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">box_size</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">mag_diff_err</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">stars</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">spoilers</span> <span class="o">=</span> <span class="n">stars</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
    <span class="n">spoilers</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">spoilers</span></div>



<div class="viewcode-block" id="get_imposter_stars">
<a class="viewcode-back" href="../../api.html#proseco.acq.get_imposter_stars">[docs]</a>
<span class="k">def</span> <span class="nf">get_imposter_stars</span><span class="p">(</span>
    <span class="n">dark</span><span class="p">,</span>
    <span class="n">star_row</span><span class="p">,</span>
    <span class="n">star_col</span><span class="p">,</span>
    <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">maxmag</span><span class="o">=</span><span class="mf">11.5</span><span class="p">,</span>
    <span class="n">box_size</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
    <span class="n">bgd</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
    <span class="n">mag_limit</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
    <span class="n">test</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Note: current alg purposely avoids using the actual flight background</span>
<span class="sd">    calculation because this is unstable to small fluctuations in values</span>
<span class="sd">    and often over-estimates background.  Using this can easily miss a</span>
<span class="sd">    search hit that the flight ACA will detect.  So just use a mean</span>
<span class="sd">    dark current ``bgd``.</span>

<span class="sd">    :param dark: dark current image (ndarray, e-/sec)</span>
<span class="sd">    :param star_row: row of acq star (float)</span>
<span class="sd">    :param star_col: col of acq star (float)</span>
<span class="sd">    :param thresh: PEA search hit threshold for a 2x2 block (e-/sec)</span>
<span class="sd">    :param maxmag: Max mag (alternate way to specify search hit ``thresh``)</span>
<span class="sd">    :param box_size: box size (arcsec)</span>
<span class="sd">    :param bgd: assumed flat background (float, e-/sec)</span>
<span class="sd">    :param mag_limit: Max mag for imposter (using 6x6 readout)</span>
<span class="sd">    :param test: hook for convenience in algorithm testing</span>

<span class="sd">    :returns: numpy structured array of imposter stars</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert row/col to array index coords unless testing.</span>
    <span class="n">rc_off</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">test</span> <span class="k">else</span> <span class="mi">512</span>
    <span class="n">acq_row</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">star_row</span> <span class="o">+</span> <span class="n">rc_off</span><span class="p">)</span>
    <span class="n">acq_col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">star_col</span> <span class="o">+</span> <span class="n">rc_off</span><span class="p">)</span>
    <span class="n">box_row</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">box_size</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
    <span class="n">box_col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">box_size</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>

    <span class="c1"># Make sure box is within CCD</span>
    <span class="n">box_r0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">acq_row</span> <span class="o">-</span> <span class="n">box_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
    <span class="n">box_r1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">acq_row</span> <span class="o">+</span> <span class="n">box_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
    <span class="n">box_c0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">acq_col</span> <span class="o">-</span> <span class="n">box_col</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
    <span class="n">box_c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">acq_col</span> <span class="o">+</span> <span class="n">box_col</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>

    <span class="c1"># Make sure box has even number of pixels on each edge.  Increase</span>
    <span class="c1"># box by one if needed.</span>
    <span class="c1">#</span>
    <span class="c1"># TO DO: Test the clipping and shrinking code</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">box_r1</span> <span class="o">-</span> <span class="n">box_r0</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">box_r1</span> <span class="o">==</span> <span class="mi">1024</span><span class="p">:</span>
            <span class="n">box_r0</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">box_r1</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">box_c1</span> <span class="o">-</span> <span class="n">box_c0</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">box_c1</span> <span class="o">==</span> <span class="mi">1024</span><span class="p">:</span>
            <span class="n">box_c0</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">box_c1</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Get bgd-subtracted dark current image corresponding to the search box</span>
    <span class="c1"># and bin in 2x2 blocks.</span>
    <span class="n">dc2x2</span> <span class="o">=</span> <span class="n">bin2x2</span><span class="p">(</span><span class="n">dark</span><span class="p">[</span><span class="n">box_r0</span><span class="p">:</span><span class="n">box_r1</span><span class="p">,</span> <span class="n">box_c0</span><span class="p">:</span><span class="n">box_c1</span><span class="p">])</span> <span class="o">-</span> <span class="n">bgd</span> <span class="o">*</span> <span class="mi">4</span>
    <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">dc2x2</span><span class="p">)</span>

    <span class="c1"># PEA search hit threshold for a 2x2 block based on count_rate(MAXMAG) / 4</span>
    <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">mag_to_count_rate</span><span class="p">(</span><span class="n">maxmag</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>  <span class="c1"># e-/sec</span>

    <span class="c1"># Get an image ``dc_labeled`` which same shape as ``dc2x2`` but has</span>
    <span class="c1"># contiguous regions above ``thresh`` labeled with a unique index.</span>
    <span class="c1"># This is a one-line way of doing the PEA merging process, roughly.</span>
    <span class="n">dc_labeled</span><span class="p">,</span> <span class="n">n_hits</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">dc2x2</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">dc_labeled</span><span class="p">)</span>

    <span class="c1"># If no hits just return empty list</span>
    <span class="k">if</span> <span class="n">n_hits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">outs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_hits</span><span class="p">):</span>
        <span class="c1"># Get row and col index vals for each merged region of search hits</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dc_labeled</span> <span class="o">==</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">dc2x2</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span>

        <span class="c1"># Centroid row, col in 2x2 binned coords.  Since we are using edge-based</span>
        <span class="c1"># coordinates, we need to at 0.5 pixels to coords for FM centroid calc.</span>
        <span class="c1"># A single pixel at coord (0, 0) has FM centroid (0.5, 0.5).</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">vals_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="n">r2x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">vals</span><span class="p">)</span> <span class="o">/</span> <span class="n">vals_sum</span>
        <span class="n">c2x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cols</span> <span class="o">*</span> <span class="n">vals</span><span class="p">)</span> <span class="o">/</span> <span class="n">vals_sum</span>

        <span class="c1"># Integer centroid row/col (center of readout image 8x8 box)</span>
        <span class="n">c_row</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">box_r0</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r2x2</span><span class="p">))</span>
        <span class="n">c_col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">box_c0</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c2x2</span><span class="p">))</span>

        <span class="c1"># Reject if too close to CCD edge</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">c_row</span> <span class="o">&lt;</span> <span class="mi">4</span>
            <span class="ow">or</span> <span class="n">c_row</span> <span class="o">&gt;</span> <span class="n">dark</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span>
            <span class="ow">or</span> <span class="n">c_col</span> <span class="o">&lt;</span> <span class="mi">4</span>
            <span class="ow">or</span> <span class="n">c_col</span> <span class="o">&gt;</span> <span class="n">dark</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span>
        <span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">img</span><span class="p">,</span> <span class="n">img_sum</span><span class="p">,</span> <span class="n">mag</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">get_image_props</span><span class="p">(</span><span class="n">dark</span><span class="p">,</span> <span class="n">c_row</span><span class="p">,</span> <span class="n">c_col</span><span class="p">,</span> <span class="n">bgd</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mag</span> <span class="o">&gt;</span> <span class="n">mag_limit</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">pea_reject_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># Revert to ACA coordinates (row,col =&gt; -512:512) unless testing, where</span>
        <span class="c1"># it is more convenient to just use normal array index coords.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">-=</span> <span class="mi">512</span>
            <span class="n">col</span> <span class="o">-=</span> <span class="mi">512</span>
            <span class="n">c_row</span> <span class="o">-=</span> <span class="mi">512</span>
            <span class="n">c_col</span> <span class="o">-=</span> <span class="mi">512</span>

        <span class="n">yang</span><span class="p">,</span> <span class="n">zang</span> <span class="o">=</span> <span class="n">pixels_to_yagzag</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">allow_bad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">row</span><span class="p">,</span>
            <span class="n">col</span><span class="p">,</span>
            <span class="n">row</span> <span class="o">-</span> <span class="n">star_row</span><span class="p">,</span>
            <span class="n">col</span> <span class="o">-</span> <span class="n">star_col</span><span class="p">,</span>
            <span class="n">yang</span><span class="p">,</span>
            <span class="n">zang</span><span class="p">,</span>
            <span class="n">c_row</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
            <span class="n">c_col</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span>
            <span class="n">img</span><span class="p">,</span>
            <span class="n">img_sum</span><span class="p">,</span>
            <span class="n">mag</span><span class="p">,</span>
            <span class="n">get_mag_std</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;d_row&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;d_col&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;yang&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;zang&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;row0&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;i8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;col0&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;i8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;img&quot;</span><span class="p">,</span> <span class="s2">&quot;f8&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;img_sum&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;mag&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;mag_err&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="n">outs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">outs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">outs</span></div>



<div class="viewcode-block" id="calc_p_brightest_compare">
<a class="viewcode-back" href="../../api.html#proseco.acq.calc_p_brightest_compare">[docs]</a>
<span class="k">def</span> <span class="nf">calc_p_brightest_compare</span><span class="p">(</span><span class="n">acq</span><span class="p">,</span> <span class="n">mags</span><span class="p">,</span> <span class="n">mag_errs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For given ``acq`` star and intruders mag, mag_err,</span>
<span class="sd">    do the probability calculation to see if the acq star is brighter</span>
<span class="sd">    than all of them.</span>

<span class="sd">    :param acq: acquisition star (AcqTable Row)</span>
<span class="sd">    :param mags: iterable of mags</span>
<span class="sd">    :param mag_errs: iterable of mag errors</span>

<span class="sd">    :returns: probability that acq stars is brighter than all mags</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>

    <span class="n">n_pts</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">([</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">])</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">n_pts</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_pts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">acq_pdf</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">])</span>

    <span class="n">sp_cdfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mag</span><span class="p">,</span> <span class="n">mag_err</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">mag_errs</span><span class="p">):</span>
        <span class="c1"># Compute prob intruder is fainter than acq (so sp_mag &gt; x).</span>
        <span class="c1"># CDF is prob that sp_mag &lt; x, so take 1-CDF.</span>
        <span class="n">sp_cdf</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">mag</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">mag_err</span><span class="p">)</span>
        <span class="n">sp_cdfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sp_cdf</span><span class="p">)</span>
    <span class="n">prod_sp_cdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sp_cdfs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mf">1e-30</span><span class="p">)</span>

    <span class="c1"># Do the integral   d p(|t) mt p(&lt;t|m)</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">acq_pdf</span> <span class="o">*</span> <span class="n">prod_sp_cdf</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">prob</span></div>



<div class="viewcode-block" id="get_intruders">
<a class="viewcode-back" href="../../api.html#proseco.acq.get_intruders">[docs]</a>
<span class="k">def</span> <span class="nf">get_intruders</span><span class="p">(</span><span class="n">acq</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">n_sigma</span><span class="p">,</span> <span class="n">get_func</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get intruders table for name=&#39;spoilers&#39; or &#39;imposters&#39; from ``acq``.</span>
<span class="sd">    If not already in acq then call ``get_func(**kwargs)`` to get it.</span>

<span class="sd">    :param acq: acq stars (AcqTable Row)</span>
<span class="sd">    :param box_size: box size (float, arcsec)</span>
<span class="sd">    :param name: intruder name (&#39;spoilers&#39; | &#39;imposters&#39;)</span>
<span class="sd">    :param n_sigma: sigma threshold for comparisons</span>
<span class="sd">    :param get_func: function to actually get spoilers or imposters</span>
<span class="sd">    :param kwargs: kwargs to pass to get_func()</span>

<span class="sd">    :returns: dict with keys yang, zang, mag, mag_err.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name_box</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_box&quot;</span>
    <span class="n">intruders</span> <span class="o">=</span> <span class="n">acq</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">box_size</span> <span class="o">=</span> <span class="n">ACABox</span><span class="p">(</span><span class="n">box_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">intruders</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">intruders</span> <span class="o">=</span> <span class="n">get_func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">acq</span><span class="p">[</span><span class="n">name_box</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_size</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intruders</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Clip to within n_sigma.  d_mag &lt; 0 for intruder brighter than acq</span>
            <span class="n">d_mag</span> <span class="o">=</span> <span class="n">intruders</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">]</span>
            <span class="n">d_mag_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">intruders</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag_err&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="n">d_mag</span> <span class="o">&lt;</span> <span class="n">n_sigma</span> <span class="o">*</span> <span class="n">d_mag_err</span>
            <span class="n">intruders</span> <span class="o">=</span> <span class="n">intruders</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
        <span class="n">acq</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">intruders</span>

    <span class="k">elif</span> <span class="n">box_size</span> <span class="o">&gt;</span> <span class="n">acq</span><span class="p">[</span><span class="n">name_box</span><span class="p">]:</span>
        <span class="c1"># Ensure cached spoilers cover the current case.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;box_size is greater than </span><span class="si">{</span><span class="n">name_box</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">colnames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;yang&quot;</span><span class="p">,</span> <span class="s2">&quot;zang&quot;</span><span class="p">,</span> <span class="s2">&quot;mag&quot;</span><span class="p">,</span> <span class="s2">&quot;mag_err&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intruders</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">intruders</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">colnames</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">intruders</span><span class="p">[</span><span class="s2">&quot;yang&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;yang&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">box_size</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">intruders</span><span class="p">[</span><span class="s2">&quot;zang&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;zang&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">box_size</span><span class="o">.</span><span class="n">z</span>
        <span class="p">)</span>
        <span class="n">intruders</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">intruders</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">ok</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">,</span> <span class="s2">&quot;mag_err&quot;</span><span class="p">]}</span>

    <span class="k">return</span> <span class="n">intruders</span></div>



<div class="viewcode-block" id="calc_p_on_ccd">
<a class="viewcode-back" href="../../api.html#proseco.acq.calc_p_on_ccd">[docs]</a>
<span class="k">def</span> <span class="nf">calc_p_on_ccd</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">box_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the probability that star and initial tracked readout box</span>
<span class="sd">    are fully within the usable part of the CCD.</span>

<span class="sd">    Note that ``box_size`` here is not a search box size, it is normally</span>
<span class="sd">    ``man_err + dither`` and reflects the size of the box where the star can</span>
<span class="sd">    land on the CCD.  This is independent of the search box size, but does</span>
<span class="sd">    assume that man_err &lt; search box size.  This is always valid because</span>
<span class="sd">    this function only gets called in that case (otherwise p_acq is just</span>
<span class="sd">    set to 0.0 in calc_p_safe.  Dither does not enter into the</span>
<span class="sd">    ``man_err &lt; search box size`` relation because the OBC accounts for</span>
<span class="sd">    dither when setting the search box position.</span>

<span class="sd">    This uses a simplistic calculation which assumes that ``p_on_ccd`` is</span>
<span class="sd">    just the fraction of box area that is within the effective usable portion</span>
<span class="sd">    of the CCD.</span>

<span class="sd">    :param row: row coordinate of star (float)</span>
<span class="sd">    :param col: col coordinate of star (float)</span>
<span class="sd">    :param box_size: box size (ACABox)</span>

<span class="sd">    :returns: probability the star is on usable part of CCD (float)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p_on_ccd</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># Require that the readout box when candidate acq star is evaluated</span>
    <span class="c1"># by the PEA (via a normal 8x8 readout) is fully on the CCD usable area.</span>
    <span class="c1"># Do so by reducing the effective CCD usable area by the readout</span>
    <span class="c1"># halfwidth (noting that there is a leading row before 8x8).</span>
    <span class="n">max_ccd_row</span> <span class="o">=</span> <span class="n">ACA</span><span class="o">.</span><span class="n">max_ccd_row</span> <span class="o">-</span> <span class="mi">5</span>
    <span class="n">max_ccd_col</span> <span class="o">=</span> <span class="n">ACA</span><span class="o">.</span><span class="n">max_ccd_col</span> <span class="o">-</span> <span class="mi">4</span>

    <span class="k">for</span> <span class="n">rc</span><span class="p">,</span> <span class="n">max_rc</span><span class="p">,</span> <span class="n">half_width</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">max_ccd_row</span><span class="p">,</span> <span class="n">box_size</span><span class="o">.</span><span class="n">row</span><span class="p">),</span>
        <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">max_ccd_col</span><span class="p">,</span> <span class="n">box_size</span><span class="o">.</span><span class="n">col</span><span class="p">),</span>
    <span class="p">):</span>
        <span class="c1"># Pixel boundaries are symmetric so just take abs(row/col)</span>
        <span class="n">rc1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="o">+</span> <span class="n">half_width</span>

        <span class="n">full_width</span> <span class="o">=</span> <span class="n">half_width</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">pix_off_ccd</span> <span class="o">=</span> <span class="n">rc1</span> <span class="o">-</span> <span class="n">max_rc</span>
        <span class="k">if</span> <span class="n">pix_off_ccd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Reduce p_on_ccd by fraction of pixels inside usable area.</span>
            <span class="n">pix_inside</span> <span class="o">=</span> <span class="n">full_width</span> <span class="o">-</span> <span class="n">pix_off_ccd</span>
            <span class="k">if</span> <span class="n">pix_inside</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p_on_ccd</span> <span class="o">*=</span> <span class="n">pix_inside</span> <span class="o">/</span> <span class="n">full_width</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p_on_ccd</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="n">p_on_ccd</span></div>



<span class="k">class</span> <span class="nc">AcqProbs</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acqs</span><span class="p">,</span> <span class="n">acq</span><span class="p">,</span> <span class="n">dither</span><span class="p">,</span> <span class="n">stars</span><span class="p">,</span> <span class="n">dark</span><span class="p">,</span> <span class="n">t_ccd</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate probabilities related to acquisition, in particular an element</span>
<span class="sd">        in the ``p_acqs`` matrix which specifies star acquisition probability</span>
<span class="sd">        for given search box size and maneuver error.</span>

<span class="sd">        This sets these attributes:</span>

<span class="sd">        - ``p_brightest``: probability this star is the brightest in box (function</span>
<span class="sd">            of ``box_size`` and ``man_err``)</span>
<span class="sd">        - ``p_acq_model``: probability of acquisition from the chandra_aca model</span>
<span class="sd">            (function of ``box_size``)</span>
<span class="sd">        - ``p_on_ccd``: probability star is on the usable part of the CCD (function</span>
<span class="sd">            of ``man_err`` and ``dither``)</span>
<span class="sd">        - ``p_acqs``: product of the above three</span>

<span class="sd">        Since chandra_aca 4.24 with the grid-floor model, the acquisition</span>
<span class="sd">        probability model value is multiplied here by 0.985 in order to help</span>
<span class="sd">        the optimization algorithm converge to a good solution.  The grid-floor</span>
<span class="sd">        model has accurate p_fail values for bright stars, in the range of</span>
<span class="sd">        0.005, but for catalogs with some bright stars this ends up skewing the</span>
<span class="sd">        p_safe calculation to where the box size of fainter stars does not make</span>
<span class="sd">        enough impact to get optimized.</span>

<span class="sd">        :param acqs: acqs table (AcqTable)</span>
<span class="sd">        :param acq: acq star (AcqTable Row) in the candidate acqs table</span>
<span class="sd">        :param dither: dither (float, arcsec)</span>
<span class="sd">        :param stars: stars table</span>
<span class="sd">        :param dark: dark current map</span>
<span class="sd">        :param t_ccd: CCD temperature (float, degC)</span>
<span class="sd">        :param date: observation date</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_brightest</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_acq_model</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_on_ccd</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_acqs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_acq_marg</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_fid_spoiler</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_fid_id_spoiler</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Convert table row to plain dict for persistence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acq</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">acq</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;yang&quot;</span><span class="p">,</span> <span class="s2">&quot;zang&quot;</span><span class="p">)}</span>

        <span class="k">for</span> <span class="n">box_size</span> <span class="ow">in</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">box_sizes</span><span class="p">:</span>
            <span class="c1"># Need to iterate over man_errs in reverse order because calc_p_brightest</span>
            <span class="c1"># caches interlopers based on first call, so that needs to have the largest</span>
            <span class="c1"># box sizes.</span>
            <span class="k">for</span> <span class="n">man_err</span> <span class="ow">in</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">man_errs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">man_err</span> <span class="o">&gt;</span> <span class="n">box_size</span><span class="p">:</span>
                    <span class="n">p_brightest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_brightest</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Prob of being brightest in box (function of box_size and</span>
                    <span class="c1"># man_err, independently because imposter prob is just a</span>
                    <span class="c1"># function of box_size not man_err).  Technically also a</span>
                    <span class="c1"># function of dither, but that does not vary here.</span>
                    <span class="n">p_brightest</span> <span class="o">=</span> <span class="n">acqs</span><span class="o">.</span><span class="n">calc_p_brightest</span><span class="p">(</span>
                        <span class="n">acq</span><span class="p">,</span> <span class="n">box_size</span><span class="o">=</span><span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="o">=</span><span class="n">man_err</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_p_brightest</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_brightest</span>

        <span class="c1"># Acquisition probability model value (function of box_size only)</span>
        <span class="k">for</span> <span class="n">box_size</span> <span class="ow">in</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">box_sizes</span><span class="p">:</span>
            <span class="n">p_acq_model</span> <span class="o">=</span> <span class="n">acq_success_prob</span><span class="p">(</span>
                <span class="n">date</span><span class="o">=</span><span class="n">date</span><span class="p">,</span>
                <span class="n">t_ccd</span><span class="o">=</span><span class="n">t_ccd</span><span class="p">,</span>
                <span class="n">mag</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;mag&quot;</span><span class="p">],</span>
                <span class="n">color</span><span class="o">=</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">],</span>
                <span class="n">spoiler</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">halfwidth</span><span class="o">=</span><span class="n">box_size</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p_acq_model</span><span class="p">[</span><span class="n">box_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_acq_model</span> <span class="o">*</span> <span class="mf">0.985</span>

        <span class="c1"># Probability star is in acq box (function of man_err and dither only)</span>
        <span class="k">for</span> <span class="n">man_err</span> <span class="ow">in</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">man_errs</span><span class="p">:</span>
            <span class="n">p_on_ccd</span> <span class="o">=</span> <span class="n">calc_p_on_ccd</span><span class="p">(</span><span class="n">acq</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">],</span> <span class="n">acq</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">],</span> <span class="n">box_size</span><span class="o">=</span><span class="n">man_err</span> <span class="o">+</span> <span class="n">dither</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p_on_ccd</span><span class="p">[</span><span class="n">man_err</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_on_ccd</span>

    <span class="k">def</span> <span class="nf">p_on_ccd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">man_err</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_on_ccd</span><span class="p">[</span><span class="n">man_err</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">p_brightest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">,</span> <span class="n">acqs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_brightest</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">p_acq_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_size</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_acq_model</span><span class="p">[</span><span class="n">box_size</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">p_acqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">,</span> <span class="n">acqs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">fid_set</span> <span class="o">=</span> <span class="n">acqs</span><span class="o">.</span><span class="n">fid_set</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_acqs</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">,</span> <span class="n">fid_set</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">p_acq</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_brightest</span><span class="p">(</span><span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">,</span> <span class="n">acqs</span><span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_acq_model</span><span class="p">(</span><span class="n">box_size</span><span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_on_ccd</span><span class="p">(</span><span class="n">man_err</span><span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_fid_spoiler</span><span class="p">(</span><span class="n">box_size</span><span class="p">,</span> <span class="n">acqs</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p_acqs</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">,</span> <span class="n">fid_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_acq</span>
            <span class="k">return</span> <span class="n">p_acq</span>

    <span class="k">def</span> <span class="nf">p_acq_marg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">acqs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">fid_set</span> <span class="o">=</span> <span class="n">acqs</span><span class="o">.</span><span class="n">fid_set</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_acq_marg</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">fid_set</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">p_acq_marg</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">man_err</span><span class="p">,</span> <span class="n">p_man_err</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ACQ</span><span class="o">.</span><span class="n">man_errs</span><span class="p">,</span> <span class="n">acqs</span><span class="o">.</span><span class="n">p_man_errs</span><span class="p">):</span>
                <span class="n">p_acq_marg</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_acqs</span><span class="p">(</span><span class="n">box_size</span><span class="p">,</span> <span class="n">man_err</span><span class="p">,</span> <span class="n">acqs</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_man_err</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p_acq_marg</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">fid_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_acq_marg</span>
            <span class="k">return</span> <span class="n">p_acq_marg</span>

    <span class="k">def</span> <span class="nf">p_fid_spoiler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">acqs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the probability multiplier based on any fid in the current fid set spoiling</span>
<span class="sd">        this acq star (within ``box_size``).  The current fid set is a property of the</span>
<span class="sd">        ``fids`` table.  The output value will be 1.0 for no spoilers and 0.0 for one or</span>
<span class="sd">        more spoiler (normally there can be at most one fid spoiler).</span>

<span class="sd">        This caches the values in a dict for subsequent access.</span>

<span class="sd">        :param acqs:</span>
<span class="sd">        :param box_size: search box size in arcsec</span>
<span class="sd">        :returns: probability multiplier (0 or 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">fid_set</span> <span class="o">=</span> <span class="n">acqs</span><span class="o">.</span><span class="n">fid_set</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_fid_spoiler</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">fid_set</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">p_fid_spoiler</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># If there are fids then multiplier the individual fid spoiler probs</span>
            <span class="k">for</span> <span class="n">fid_id</span> <span class="ow">in</span> <span class="n">fid_set</span><span class="p">:</span>
                <span class="n">p_fid_spoiler</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_fid_id_spoiler</span><span class="p">(</span><span class="n">box_size</span><span class="p">,</span> <span class="n">fid_id</span><span class="p">,</span> <span class="n">acqs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p_fid_spoiler</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">fid_set</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_fid_spoiler</span>

            <span class="k">return</span> <span class="n">p_fid_spoiler</span>

    <span class="k">def</span> <span class="nf">p_fid_id_spoiler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">fid_id</span><span class="p">,</span> <span class="n">acqs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the probability multiplier for fid ``fid_id`` spoiling this acq star (within</span>
<span class="sd">        ``box_size``).  The output value will be 0.0 if this fid spoils this acq, otherwise</span>
<span class="sd">        set to 1.0 (no impact).</span>

<span class="sd">        This caches the values in a dict for subsequent access.</span>

<span class="sd">        :param acqs:</span>
<span class="sd">        :param box_size: search box size in arcsec</span>
<span class="sd">        :returns: probability multiplier (0 or 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">acqs</span><span class="o">.</span><span class="n">cand_acqs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_fid_id_spoiler</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">fid_id</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">fids</span> <span class="o">=</span> <span class="n">acqs</span><span class="o">.</span><span class="n">fids</span>
            <span class="k">if</span> <span class="n">fids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">acqs</span><span class="o">.</span><span class="n">add_warning</span><span class="p">(</span>
                    <span class="s2">&quot;Requested fid spoiler probability without &quot;</span>
                    <span class="s2">&quot;setting acqs.fids first&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="mf">1.0</span>

            <span class="n">p_fid_id_spoiler</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fid</span> <span class="o">=</span> <span class="n">fids</span><span class="o">.</span><span class="n">cand_fids</span><span class="o">.</span><span class="n">get_id</span><span class="p">(</span><span class="n">fid_id</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
                <span class="c1"># This should not happen, but ignore with a warning in any case.  Non-candidate</span>
                <span class="c1"># fid cannot spoil an acq star.</span>
                <span class="n">acqs</span><span class="o">.</span><span class="n">add_warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Requested fid spoiler probability for fid &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">acqs</span><span class="o">.</span><span class="n">detector</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">fid_id</span><span class="si">}</span><span class="s2"> but it is &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;not a candidate&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fids</span><span class="o">.</span><span class="n">spoils</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq</span><span class="p">,</span> <span class="n">box_size</span><span class="p">):</span>
                    <span class="n">p_fid_id_spoiler</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_p_fid_id_spoiler</span><span class="p">[</span><span class="n">box_size</span><span class="p">,</span> <span class="n">fid_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_fid_id_spoiler</span>

            <span class="k">return</span> <span class="n">p_fid_id_spoiler</span>


<div class="viewcode-block" id="get_p_man_err">
<a class="viewcode-back" href="../../api.html#proseco.acq.get_p_man_err">[docs]</a>
<span class="k">def</span> <span class="nf">get_p_man_err</span><span class="p">(</span><span class="n">man_err</span><span class="p">,</span> <span class="n">man_angle</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Probability for given ``man_err`` given maneuver angle ``man_angle``.</span>

<span class="sd">    :param man_err: maneuver error (float, arcsec)</span>
<span class="sd">    :param man_angle: maneuver angle (float, deg)</span>

<span class="sd">    :returns: probability of man_error for given man_angle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pmea</span> <span class="o">=</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">p_man_errs_angles</span>  <span class="c1"># [0, 5, 20, 40, 60, 80, 100, 120, 180]</span>
    <span class="n">pme</span> <span class="o">=</span> <span class="n">ACQ</span><span class="o">.</span><span class="n">p_man_errs</span>
    <span class="n">man_angle_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pmea</span><span class="p">,</span> <span class="n">man_angle</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">man_angle</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pmea</span><span class="p">[</span><span class="n">man_angle_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pmea</span><span class="p">[</span><span class="n">man_angle_idx</span><span class="p">])</span>

    <span class="n">man_err_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pme</span><span class="p">[</span><span class="s2">&quot;man_err_hi&quot;</span><span class="p">],</span> <span class="n">man_err</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">man_err_idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pme</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;man_err must be &lt;= </span><span class="si">{</span><span class="n">pme</span><span class="p">[</span><span class="s2">&quot;man_err_hi&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pme</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">man_err_idx</span><span class="p">]</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2018, Tom Aldcroft, Jean Connelly.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.2.6. &nbsp;
  </p>
</footer>
  </body>
</html>